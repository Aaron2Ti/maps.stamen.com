<!DOCTYPE html>
<html>
  <head>

    <style type="text/css">
        @import url(css/bootstrap.css);
        @import url(css/screen.css);
        @import url(css/layer.css);
    </style>

    <style>

      body {
        background: #1a1a1a;
        padding: 0;
        margin: 0;
      }
    
      #map,
      canvas,
      svg,
      #threed,
      div {
        margin: 0;
        padding: 0;
      }

      svg {
        width: 3000px;
        height: 3000px;
        overflow: hidden;
      }

      #threed {
        visibility: visible;
      }

      #map {
        visibility: hidden;
      }

      #threed {
        margin: 0;
        padding: 0;
        position: absolute;
        top: 0;
        left: 0;
        z-index: -9999;
      }

      #logo {
        position: fixed;
        bottom: 20px;
        right: 20px;
        width: 180px;
        height: 60px;
        background-image: url("img/stamen_logo_white.png");
      }

      #header h1 span {
        color: #e25d4e;
      }

      .controls a {
        background: #e25d4e;
      }

      h1#toggle {
          cursor: pointer;
          font-weight: bold;
          /*color: black;*/
          /*background: yellow;*/
          text-decoration: none;
          /*padding: 3px 10px 6px 10px;*/
          display: block;
          float: left;
          /*margin-right: 8px;*/
          font-size: 24px;
          color: #ccc;
      }

      #pan-up,
      #pan-down,
      #cam-up,
      #cam-down,
      #reset {
        margin-top: 8px;
      }

      #reset {
        font-size: 16px;
      }

      .block {
        clear: both;
      }

      #header {
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        -khtml-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
      }

    </style>

    <meta charset="utf-8">
    
    <script src="js/d3.v3.js"></script>
    <script src="js/polymaps.mod.js"></script>

    <script src="js/three.js"></script>
    <script src="js/keyboard.js"></script>

  </head>

  <body>

    <div id="header" class="navbar">
        <div class="navbar-inner">
            <h1 id="tiles" class="brand"><a id="home-link" href="../">maps.stamen.com</a> / <span id="current-provider">mars</span></h1>
            <!-- <h1 id="toggle">2d/3d</h1> -->
            <a id="stamen" class="brand" href="http://stamen.com">stamen</a>
        </div>
    </div>

    <div id="overlay">
        <div id="controls" class="controls">
<!--             <div class="block">
              <a id="zoom-in" title="zoom in">+</a>
              <a id="zoom-out" title="zoom out">&minus;</a>
            </div> -->
            
            <div class="block">
              <a id="pan-up" title="pan up">+</a>
              <a id="pan-down" title="pan down">&minus;</a>
            </div>

            <div class="block">
              <a id="cam-up" title="camera up">+</a>
              <a id="cam-down" title="camera down">&minus;</a>
            </div>

            <div class="block">
              <a id="reset" title="reset view">RESET</a>
            </div>
        </div>
    </div>


    <div id="map"></div>
    <div id="threed"></div>

    <script>

      // keyboard
      var jump = 10;

      // controls besides zoom
      var moveInterval;
      d3.selectAll(".block a").on("mousedown", function() {
        // console.log("id:", this.id);

        var motion = this.id;
        moveCamera(motion);
        moveInterval = setInterval(function() {
          moveCamera(motion);
        }, 20);

        d3.select("body").on("mouseup", function() {
          clearInterval(moveInterval);
          map.dispatch({type: "move"});
        });

      });

      function moveCamera(motion) {
        switch (motion) {
          case "pan-down":
            camera.position.z -= jump;
            break;
          case "pan-up":
            camera.position.z += jump;
            break;
          case "cam-up":
            camera.rotation.x += 0.01;
            break;
          case "cam-down":
            camera.rotation.x -= 0.01;
            break;
          case "reset":
            resetCameraPosition();
            break;
          default:
            break;
        };
      }

      function nextPosition(angle) {
        // take a current angle and calculate x,y coordinates for the next step
        var r = 200,
            cx = 0,
            cy = 0;
        var x = cx + r * Math.cos(angle),
            y = cy + r * Math.sin(angle);
        camera.position.x = x;
        camera.position.y = y;
      }

    </script>


    <script>

      var zoom = {min: 6, max: 6};

      // controls
      d3.select("#zoom-in").on("click", function() {
        if (map.zoom() != zoom.max) map.zoom(map.zoom() + 1);
      });

      d3.select("#zoom-out").on("click", function() {
        if (map.zoom() != zoom.min) map.zoom(map.zoom() - 1);
      });

      // 2d/3d toggle
      // d3.select("#toggle").on("click", function() {
      //   d3.select("#threed")
      //     .style("visibility", function() { 
      //       return this.style.visibility === "visible" ? "hidden" : "visible"; 
      //     });

      //   d3.select("#map")
      //     .style("visibility", function() { 
      //       return this.style.visibility === "visible" ? "hidden" : "visible"; 
      //     });
      // });

      var scene = new THREE.Scene(),
          camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 10000 ),
          renderer = new THREE.WebGLRenderer(),
          polyTiles = {},
          threeTiles = {};

      renderer.setSize( window.innerWidth, window.innerHeight ); 
      document.getElementById("threed").appendChild( renderer.domElement );

      var defaultCameraPos = [0, -600, 400, Math.PI/4];
      function resetCameraPosition() {
        var pos = defaultCameraPos;
        camera.position = new THREE.Vector3(pos[0], pos[1], pos[2]);
        camera.rotation.x = parseFloat(pos[3]).toFixed(3);
      }
      resetCameraPosition();

      function dtor(d) {
        return (d / 180 * Math.PI);
      }

      var hash = function() {
        var lat = lat = 90 - 1e-8, // allowable latitude range
            s0;

        function hashMove() {
          var s1 = formatter(map);
          if (s0 !== s1) location.replace(s0 = s1); // don't recenter the map!
        }

        // parsing and formatting the url hash (z/lon/lat/camX/camY/camZ/camRotationX)
        function parser(map, urlHash) {
          var args = urlHash.split("/").map(Number);
          if ((args.length < 7 && map.angle() !== 0) || args.some(isNaN)) {
            // replace bogus hash
            hashMove();
          } else {
            // map.angle(dtor(args[3]) || 0);
            camera.position.x = args[3] || defaultCameraPos[0];
            camera.position.y = args[4] || defaultCameraPos[1];
            camera.position.z = args[5] || defaultCameraPos[2];
            camera.rotation.x = args[6] || defaultCameraPos[3];
            var size = map.size();
            map.zoomBy(args[0] - map.zoom(),
                {x: size.x / 2, y: size.y / 2},
                {lat: Math.min(lat, Math.max(-lat, args[1])), lon: args[2]});
            map.dispatch({type: "move"});
          }
        }

        function formatter(map) {
          var center = map.center(),
              zoom = map.zoom(),
              precision = Math.max(0, Math.ceil(Math.log(zoom) / Math.LN2));
          var hash = "#" + [
            Math.round(zoom), 
            center.lat.toFixed(precision), 
            center.lon.toFixed(precision),
            camera.position.x,
            camera.position.y,
            camera.position.z,
            parseFloat(camera.rotation.x).toFixed(3)
          ].join("/");
          if (map.angle() !== 0) hash += "/" + rtod(map.angle()).toFixed(2);
          return hash;
        };

        return po.hash()
          .parser(parser)
          .formatter(formatter);
      };

      var po = org.polymaps;

      var map = po.map()
        .container(document.getElementById("map").appendChild(po.svg("svg")))
        .center({lat: 10.034, lon: -62.161})
        .zoomRange([zoom.min, zoom.max])
        .zoom(6)
        .add(po.drag())
        .add(hash());
        // .add(po.hash());

        map.add(po.geoJson()
          // .url("http://127.0.0.1:8080/mars-contours-simple/{Z}/{X}/{Y}.geojson")
          // .url("http://127.0.0.1:8080/mars-psql/{Z}/{X}/{Y}.geojson")
          // .url("http://brillo.local:8080/mars-psql-vec/{Z}/{X}/{Y}.json")
          // .url("tilecache/mars-psql-vec/{Z}/{X}/{Y}.json")
          .url("http://mars.data.stamen.com/tiles/{Z}/{X}/{Y}.json")
          .on("load", load));

        var contourColor = d3.scale.quantize()
              .domain([-8000, 29000])
              .range(["#e6550d", "#fd8d3c", "#fdae6b", "#fdd0a2", "#fff", "#6baed6", "#9ecae1", "#c6dbef"]);

        function load(tile) {

          // if (!polyTiles[tile.tile.key]) {
          var threeTile = new THREE.Object3D(),
              tk = tile.tile.key;
          threeTile.key = tk;
          polyTiles[tk] = tile.tile;

          var size = map.size(),
              offset = {
                x: tile.tile.x + size.x/2,
                y: tile.tile.y + 256 + size.y/2     // XXX why +tileSize?
              };

          for (var i = 0; i < tile.features.length; i++) {
            var feature = tile.features[i],
                el = d3.select(feature.element),
                height = (feature.data.properties.contour+8000)/29000; // +8000 bc min is -8000, /29000 bc max is 29000; FIX
                // color = "hsl(" + height*360 + ", 100%, 70%)";

            var color = contourColor(feature.data.properties.contour);

            el.style("fill", "none")
              .style("stroke-width", 1)
              .style("stroke", color);
              // .style("opacity", 0.1);
        
            var geometry = new THREE.Geometry();

            // console.log(feature.data.geometry.type, feature);

            var tileGeometry = feature.data.geometry,
                type = tileGeometry.type.toLowerCase();

            if (type === "multilinestring") {
              continue;
              // var coordinates = [];
              // tileGeometry.coordinates.forEach(function(coordinateArray) {
              //   // XXX FIX: this will CONNECT the lines. very bad, homie.
              //   coordinates = coordinates.concat(coordinateArray);
              // });
            } else if (type === "linestring") {
              var coordinates = tileGeometry.coordinates;
            } else {
              // geometry collection wtf
              // console.log(tileGeometry.type, feature);
              continue;
            }

            coordinates.forEach(function(coord, coordIdx) {
              var point = map.locationPoint({lon: coord[0], lat: coord[1]}),
                  px = point.x - offset.x,
                  py = point.y - offset.y;
              geometry.vertices.push(
                new THREE.Vector3(
                   px, 
                  -py,
                   height * 150
                   //feature.data.properties.CONTOUR/10000   // XXX FIX to a real scale
                )
              );
            });

            // var color = new THREE.Color(0xffffff);
            // color.setHSL(height, 1, 0.7);
            var color = new THREE.Color(color);
            var material = new THREE.LineBasicMaterial({
              color: color
            });

            var line = new THREE.Line(geometry, material);
            // threeTiles.add(line);
            threeTile.add(line);
          }
          // console.log("threeTile:", threeTile, "tile:", tile);
          var translate = tile.tile.translate;
          threeTile.position.x =  translate[0];
          threeTile.position.y = -translate[1] - 256;

          scene.add(threeTile);
          threeTiles[tk] = threeTile;
          // console.log(tile.tile.translate);
          // console.log("added", tile.tile.key, d3.keys(polyTiles).length, d3.keys(threeTiles).length);
          // }
        }

        map.on("move", move);

        function move() {
          // var mapZoom = Math.round(mapZoom);
          // map.zoom(Math.round(map.zoom()));
          var mapZoom = map.zoom();

          var tiles = [];
          for (var key in polyTiles) {
            if (polyTiles[key].zoom === mapZoom) {
              tiles.push(polyTiles[key]);
            } else if (threeTiles[key]) {
              //unload( tilesByKey[key] );
              threeTiles[key].visible = false;
              scene.remove(threeTiles[key]);
            } else {
              console.log("no obj for tile", key);
            }
          }

          // var threeKeys = Object.keys(threeTiles);
          // threeKeys.forEach(function(key) {
          //   var threeTile = threeTiles[key];
          //   if (polyTiles[key]) {
          //     var polyTile = polyTiles[key].tile;
          //     if (!polyTile.element.parentNode) {
          //       scene.remove(threeTile);
          //       delete threeTiles[key];
          //     } else {
          //       threeTile.position.x =  polyTile.translate[0];
          //       threeTile.position.y = -polyTile.translate[1];
          //     }
          //   } else {
          //     scene.remove(threeTile);
          //     delete threeTiles[key];
          //   }
          // });

          // console.log(tiles);
          var tileSize = {x: 256, y: 256};
          // adapted from Nokia:
          tiles.forEach(function(tile) {
            var obj = threeTiles[tile.key];
            if (tile.element.parentNode) {
              if (obj) {
                obj.position.x =  tile.translate[0];
                obj.position.y = -tile.translate[1] - tileSize.y;

                // console.log("moving 3d tile obj:", obj.position);

                if (!obj.visible) {
                  obj.visible = true;
                  scene.add(obj);
                }
              } else {
                // XXX reload tile?
              }
            } else {
              if (obj) {
                // XXX might go away
                scene.remove(obj);
                obj.visible = false;
              }
            }
          });

          var mapSize = map.size(),
              mapZoom = map.zoom(),
              mapZoomFraction = mapZoom - (mapZoom = Math.round(mapZoom));

          var transform = {
            translate: [mapSize.x / 2, mapSize.y / 2],
            scale: Math.pow(2, mapZoomFraction)
          };



          // map.layer.dispatch({
          //   type: "transform",
          //   transform: transform,
          //   tiles: tiles
          // });

        }

        function render() {
          requestAnimationFrame(render); 
          renderer.render(scene, camera); 
        }
        render();

      // })(this);

    </script>


  </body>


</html>